(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{377:function(t,e,r){"use strict";r.r(e);var a=r(42),_=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("p",[r("a",{attrs:{href:"https://juejin.im/post/5872309261ff4b005c4580d4",target:"_blank",rel:"noopener noreferrer"}},[t._v("了解 Web 及网络基础"),r("OutboundLink")],1)]),t._v(" "),r("p",[r("a",{attrs:{href:"https://juejin.im/entry/5981c5df518825359a2b9476",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTP1.0、HTTP1.1 和 HTTP2.0 的区别"),r("OutboundLink")],1)]),t._v(" "),r("p",[r("a",{attrs:{href:"https://juejin.im/post/5a1d4e546fb9a0450f21af23",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTP缓存机制"),r("OutboundLink")],1)]),t._v(" "),r("p",[r("a",{attrs:{href:"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTP 缓存"),r("OutboundLink")],1)]),t._v(" "),r("p",[r("a",{attrs:{href:"https://juejin.im/post/5ef153cc51882565901ea744?utm_source=gold_browser_extension",target:"_blank",rel:"noopener noreferrer"}},[t._v("【前端面试题】 说一下cdn的原理"),r("OutboundLink")],1)]),t._v(" "),r("p",[t._v("https://juejin.im/post/5eb16e226fb9a043661f7e1d")]),t._v(" "),r("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://user-gold-cdn.xitu.io/2017/1/8/2f37ad4d1d33898a58dce80f0eccad0a?imageView2/0/w/1280/h/960/ignore-error/1"}}),t._v(" "),r("p",[t._v("发送端在层与层间传输数据时，每经过一层都会被加上首部信息，接收端每经过一层都会删除一条首部")]),t._v(" "),r("h3",{attrs:{id:"简单的-http-协议"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#简单的-http-协议"}},[t._v("#")]),t._v(" 简单的 HTTP 协议")]),t._v(" "),r("h5",{attrs:{id:"请求报文和响应报文"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#请求报文和响应报文"}},[t._v("#")]),t._v(" 请求报文和响应报文")]),t._v(" "),r("p",[t._v("客户端像服务器发起请求时会生成一段请求报文，请求报文是由请求方法，URL，协议版本，可选的请求首部字段和内容实体构成。")]),t._v(" "),r("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2017/1/8/e6a04516c5718cd294566461d7149aef?imageslim"}}),t._v(" "),r("p",[t._v("接收到请求的服务器，会将请求内容的处理结构以响应的形式返回。响应报文基本上由协议版本，状态码，用以解释状态的原因短语，可选的响应首部字段以及实体主体构成。")]),t._v(" "),r("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2017/1/8/59b3b008941490fecd38955c42026438?imageslim"}}),t._v(" "),r("h5",{attrs:{id:"http-是不保存状态的协议和-cookie-的简单介绍"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#http-是不保存状态的协议和-cookie-的简单介绍"}},[t._v("#")]),t._v(" HTTP 是不保存状态的协议和 Cookie 的简单介绍")]),t._v(" "),r("p",[t._v("HTTP 协议对于发送的请求和响应不做持久化处理。这时候引入了 Cookie 技术用于状态管理。Cookie 对用与登录的状态管理，没有 Cookie 这个技术的话，因为 HTTP 不保存状态，每次打开新网页都必须再次登录。")]),t._v(" "),r("p",[t._v("Cookie 会根据响应报文中的 Set-Cookie 字段来通知客户端自动保存 Cookie。下次请求时会自动发送 Cookie，服务器会比对数据得到状态结果。")]),t._v(" "),r("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2017/1/8/4f4dbd71844417c74a36b0382e0f8a98?imageslim"}}),t._v(" "),r("h4",{attrs:{id:"post-和-get-的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#post-和-get-的区别"}},[t._v("#")]),t._v(" Post 和 Get 的区别")]),t._v(" "),r("p",[t._v("先引入副作用和幂等的概念。")]),t._v(" "),r("p",[t._v("副作用指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。")]),t._v(" "),r("p",[t._v("幂等指发送 M 和 N 次请求（两者不相同且都大于1），服务器上资源的状态一致。注册10个和11个帐号是不幂等的，对文章进行更改10次和11次是幂等的。")]),t._v(" "),r("p",[t._v("在规范的应用场景上说，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册。")]),t._v(" "),r("p",[t._v("在技术上说：")]),t._v(" "),r("ul",[r("li",[t._v("Get 请求能缓存，Post 不能")]),t._v(" "),r("li",[t._v("Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。")]),t._v(" "),r("li",[t._v("Post 可以通过 request body来传输比 Get 更多的数据，Get 没有这个技术")]),t._v(" "),r("li",[t._v("URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的")]),t._v(" "),r("li",[t._v("Post 支持更多的编码类型且不对数据类型限制")])]),t._v(" "),r("h4",{attrs:{id:"常见状态码"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#常见状态码"}},[t._v("#")]),t._v(" 常见状态码")]),t._v(" "),r("h5",{attrs:{id:"_2xx-成功"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2xx-成功"}},[t._v("#")]),t._v(" 2XX 成功")]),t._v(" "),r("ul",[r("li",[t._v("200 OK，表示从客户端发来的请求在服务器端被正确处理")]),t._v(" "),r("li",[t._v("204 No content，表示请求成功，但响应报文不含实体的主体部分")]),t._v(" "),r("li",[t._v("206 Partial Content，进行范围请求")])]),t._v(" "),r("h5",{attrs:{id:"_3xx-重定向"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3xx-重定向"}},[t._v("#")]),t._v(" 3XX 重定向")]),t._v(" "),r("ul",[r("li",[t._v("301 moved permanently，永久性重定向，表示资源已被分配了新的 URL")]),t._v(" "),r("li",[t._v("302 found，临时性重定向，表示资源临时被分配了新的 URL")]),t._v(" "),r("li",[t._v("303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源")]),t._v(" "),r("li",[t._v("304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况")]),t._v(" "),r("li",[t._v("307 temporary redirect，临时重定向，和302含义相同")])]),t._v(" "),r("h5",{attrs:{id:"_4xx-客户端错误"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4xx-客户端错误"}},[t._v("#")]),t._v(" 4XX 客户端错误")]),t._v(" "),r("ul",[r("li",[t._v("400 bad request，请求报文存在语法错误")]),t._v(" "),r("li",[t._v("401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息")]),t._v(" "),r("li",[t._v("403 forbidden，表示对请求资源的访问被服务器拒绝")]),t._v(" "),r("li",[t._v("404 not found，表示在服务器上没有找到请求的资源")])]),t._v(" "),r("h5",{attrs:{id:"_5xx-服务器错误"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5xx-服务器错误"}},[t._v("#")]),t._v(" 5XX 服务器错误")]),t._v(" "),r("ul",[r("li",[t._v("500 internal sever error，表示服务器端在执行请求时发生了错误")]),t._v(" "),r("li",[t._v("503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求")])]),t._v(" "),r("h4",{attrs:{id:"http-首部"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#http-首部"}},[t._v("#")]),t._v(" HTTP 首部")]),t._v(" "),r("h5",{attrs:{id:"通用首部"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#通用首部"}},[t._v("#")]),t._v(" 通用首部")]),t._v(" "),r("p",[t._v("指请求报文和响应报文都可以使用的字段")]),t._v(" "),r("ul",[r("li",[t._v("Cache-Control\n"),r("ul",[r("li",[t._v("no-cache 指客户端不缓存过期资源")]),t._v(" "),r("li",[t._v("no-store 指不进行缓存")]),t._v(" "),r("li",[t._v("max-age 指缓存资源的缓存时间比指定的值小，那么客户端就接受缓存资源，且缓存服务器不对资源有效性进行再次确认")])])]),t._v(" "),r("li",[t._v("Connection 指控制不再转发给代理的首部字段（Hop-by-hop），管理持久连接\n"),r("ul",[r("li",[t._v("close 指服务器像明确断开连接")]),t._v(" "),r("li",[t._v("Keep-Alive 指保存持久连接，HTTP/1.1前默认连接是非持久性的，如需要保存持久连接，需要增加此字段")])])]),t._v(" "),r("li",[t._v("Upgrade 可以用来指定一个完全不同的通信协议，对于这个字段，服务器可以返回101状态码")])]),t._v(" "),r("h5",{attrs:{id:"请求首部字段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#请求首部字段"}},[t._v("#")]),t._v(" 请求首部字段")]),t._v(" "),r("ul",[r("li",[t._v("Accept 指用户代理能够处理的媒体类型及媒体类型的相对优先级")]),t._v(" "),r("li",[t._v("Accept-Encoding 指用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序")]),t._v(" "),r("li",[t._v("Authorization 指用来告知服务器，用户代理的认证信息")]),t._v(" "),r("li",[t._v("Host 当一个 IP 下存在多个域名时，帮助服务器知道要请求的具体主机")]),t._v(" "),r("li",[t._v("User-Agent 会讲创建请求的浏览器和用户代理名称等信息传达给服务器")])]),t._v(" "),r("h4",{attrs:{id:"https"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[t._v("#")]),t._v(" HTTPS")]),t._v(" "),r("p",[t._v("HTTPS 是 HTTP 建立在 SSL/TLS 安全协议上的。")]),t._v(" "),r("p",[t._v("在 iOS 中，客户端本地会存放着 CA 证书，在HTTPS 请求时，会首先像服务器索要公钥，获得公钥后会使用本地 CA 证书验证公钥的正确性，然后通过正确的公钥加密信息发送给服务器，服务器会使用私钥解密信息。")]),t._v(" "),r("p",[t._v("SSL/TLS握手阶段分为五步： 以下引自 "),r("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("阮一峰的网络日志"),r("OutboundLink")],1),t._v('\n第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。\n第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。\n第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。\n第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。\n第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来加密接下来的整个对话过程。')]),t._v(" "),r("p",[t._v("HTTPS 相对于 HTTP 性能上差点，因为多了 SSL/TLS 的几次握手和加密解密的运算处理，但是加密解密的运算处理已经可以通过特有的硬件来加速处理。")]),t._v(" "),r("h4",{attrs:{id:"强制缓存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#强制缓存"}},[t._v("#")]),t._v(" 强制缓存")]),t._v(" "),r("p",[t._v("当缓存数据库中已有所请求的数据时。客户端直接从缓存数据库中获取数据。当缓存数据库中没有所请求的数据时，客户端的才会从服务端获取数据。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2017/11/29/16007be6f64ff7f7?imageView2/0/w/1280/h/960/ignore-error/1",alt:"img"}})]),t._v(" "),r("h4",{attrs:{id:"协商缓存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),r("p",[t._v("又称对比缓存，客户端会先从缓存数据库中获取到一个缓存数据的标识，得到标识后请求服务端验证是否失效（新鲜），如果没有失效服务端会返回304，此时客户端直接从缓存中获取所请求的数据，如果标识失效，服务端会返回更新后的数据。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2017/11/29/16007d1c835d5461?imageView2/0/w/1280/h/960/ignore-error/1",alt:"img"}})]),t._v(" "),r("h4",{attrs:{id:"缓存的方案"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缓存的方案"}},[t._v("#")]),t._v(" 缓存的方案")]),t._v(" "),r("p",[r("strong",[t._v("强制缓存")]),t._v("，服务器响应的header中会用两个字段来表明——Expires和Cache-Control。")]),t._v(" "),r("p",[t._v("Exprires的值为服务端返回的数据到期时间。")]),t._v(" "),r("p",[t._v("Cache-Control有很多属性，不同的属性代表的意义也不同。 private：客户端可以缓存 public：客户端和代理服务器都可以缓存 max-age=t：缓存内容将在t秒后失效 no-cache：需要使用协商缓存来验证缓存数据 no-store：所有内容都不会缓存。")]),t._v(" "),r("p",[r("strong",[t._v("协商缓存")]),t._v("需要进行对比判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回304状态码，浏览器拿到此状态码就可以直接使用缓存数据了。 对于协商缓存来说，缓存标识我们需要着重理解一下，下面我们将着重介绍它的两种缓存方案。")]),t._v(" "),r("p",[t._v("Last-Modified： 服务器在响应请求时，会告诉浏览器资源的最后修改时间。")]),t._v(" "),r("p",[t._v("Etag： 服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）")]),t._v(" "),r("h4",{attrs:{id:"缓存的优点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缓存的优点"}},[t._v("#")]),t._v(" 缓存的优点")]),t._v(" "),r("ol",[r("li",[r("p",[t._v("减少了冗余的数据传递，节省宽带流量")])]),t._v(" "),r("li",[r("p",[t._v("减少了服务器的负担，大大提高了网站性能")])]),t._v(" "),r("li",[r("p",[t._v("加快了客户端加载网页的速度 这也正是HTTP缓存属于客户端缓存的原因。")])])]),t._v(" "),r("h4",{attrs:{id:"不同刷新的请求执行过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#不同刷新的请求执行过程"}},[t._v("#")]),t._v(" 不同刷新的请求执行过程")]),t._v(" "),r("ol",[r("li",[t._v("浏览器地址栏中写入URL，回车 浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）")]),t._v(" "),r("li",[t._v("F5 F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上If-Modify-since。")]),t._v(" "),r("li",[t._v("Ctrl+F5 告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作.")])])])}),[],!1,null,null,null);e.default=_.exports}}]);