(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{376:function(t,s,a){"use strict";a.r(s);var n=a(42),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h4",{attrs:{id:"内存泄漏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存泄漏"}},[t._v("#")]),t._v(" 内存泄漏")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("定义:无效引用即无法被程序使用，但又没有被系统回收的内存。")])]),t._v(" "),a("li",[a("p",[t._v("垃圾回收(GC) 原理:"),a("strong",[t._v("标记-清除")]),t._v("算法")]),t._v(" "),a("p",[t._v("(1) 垃圾回收机制维护一系列的根节点，例如window, globle对象等,这些根节点所占用的内存不会被回收;")]),t._v(" "),a("p",[t._v("(2)从根节点出发，递归的检查子节点，根节点和所有子节点都标记为引用状态，内存不会被回收;")]),t._v(" "),a("p",[t._v("(3)所有没有标记的内存块,视为垃圾内存，自动回收,由系统重新分配;")])]),t._v(" "),a("li",[a("p",[t._v("几种常见的内存泄漏")]),t._v(" "),a("p",[t._v("(1) 全局变量: xxx === window.xxx")]),t._v(" "),a("p",[t._v("​\t解决办法: var let const ;如果不得不使用全局变量， 引用之后，手动设置xxx = null")]),t._v(" "),a("p",[t._v("(2) setInterval中弓 |用的变量和对象:未清除定时器，这些变量和对象一-直存在内存中")]),t._v(" "),a("p",[t._v("​\t解决办法: clearInterval ()清除定时器")]),t._v(" "),a("p",[t._v("(3) dom事件没有移除: dom节 点被移除但事件依然存在内存中")]),t._v(" "),a("p",[t._v("​\t解决办法: removeEventListener")]),t._v(" "),a("p",[t._v("(4)循环引用:")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" b "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\na"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("r "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nb"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("r "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("这种情况下，老的技术算法")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("IE6")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("IE7")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("会存在内存泄露，标记清除算法不会内存泄露！\n")])])]),a("p",[t._v("(5) dom移出:")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" select "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("querySelector"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" treeRef "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("select")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'#tree'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" leafRef "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("select")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'#leaf'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//在COM树中leafRef是treeFre的一个子节点")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("select")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'body'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("removeChild")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("treeRef"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//#tree不能被会收入，因为treeRef还在")]),t._v("\n")])])]),a("p",[t._v("(6) 闭包")])])]),t._v(" "),a("h4",{attrs:{id:"垃圾回收机制-或者叫-gc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收机制-或者叫-gc"}},[t._v("#")]),t._v(" 垃圾回收机制 或者叫 GC")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.im/post/5b684f30f265da0f9f4e87cf",target:"_blank",rel:"noopener noreferrer"}},[t._v("javascript 垃圾回收机制"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.im/post/5a6b3fcaf265da3e2c385375",target:"_blank",rel:"noopener noreferrer"}},[t._v("简单了解JavaScript垃圾回收机制"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("现在各大浏览器通常用采用的垃圾回收有两种方法：标记清除、引用计数。\n1、标记清除")]),t._v(" "),a("p",[t._v("这是javascript中最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。\n　　垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。")]),t._v(" "),a("p",[t._v("2、引用计数")]),t._v(" "),a("p",[t._v("另一种不太常见的垃圾回收策略是引用计数。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。")]),t._v(" "),a("p",[t._v("3、新生代算法")]),t._v(" "),a("p",[t._v("在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("Js 垃圾回收机制 (GC) , (高管垃圾)")]),t._v(" "),a("p",[t._v("引用计数、标记清除压缩、复制 from to 空间")])])}),[],!1,null,null,null);s.default=e.exports}}]);