(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{366:function(v,_,t){"use strict";t.r(_);var a=t(42),r=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[t("a",{attrs:{href:"https://juejin.im/post/5b5f20686fb9a04f844adbdd#heading-8",target:"_blank",rel:"noopener noreferrer"}},[v._v("搞定计算机网络面试，看这篇就够了"),t("OutboundLink")],1)]),v._v(" "),t("h4",{attrs:{id:"tcp的主要特点："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp的主要特点："}},[v._v("#")]),v._v(" TCP的主要特点：")]),v._v(" "),t("ol",[t("li",[v._v("TCP是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；")]),v._v(" "),t("li",[v._v("每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；")]),v._v(" "),t("li",[v._v("TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；")]),v._v(" "),t("li",[v._v("TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；")]),v._v(" "),t("li",[v._v("面向字节流。TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。")])]),v._v(" "),t("hr"),v._v(" "),t("h4",{attrs:{id:"tcp连接如何保证安全可靠的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp连接如何保证安全可靠的"}},[v._v("#")]),v._v(" TCP连接如何保证安全可靠的")]),v._v(" "),t("p",[v._v("TCP传输是可靠的,原因如下：")]),v._v(" "),t("p",[v._v("（1）TCP协议采用发送应答机制，即发送端发送的每个TCP报文段都必须得到接收方的应答，才能认为这个TCP报文段传输成功。")]),v._v(" "),t("p",[v._v("（2）TCP协议采用超时重传机制，发送端在发送出一个TCP报文段之后启动定时器，如果在定时时间内未收到应答，它将重新发送该报文段。")]),v._v(" "),t("p",[v._v("（3）由于TCP报文段最终是以IP数据报发送的，而IP数据报到达接收端可能乱序、重复、所以TCP协议还会将接收到的TCP报文段重排、整理、再交付给应用层。")]),v._v(" "),t("p",[v._v("UDP协议则和IP协议一样，提供的是不可靠的服务。它们都需要上层协议来处理数据确认和超时重传")]),v._v(" "),t("hr"),v._v(" "),t("h4",{attrs:{id:"为什么tcp连接需要三次握手，两次不可以吗，为什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么tcp连接需要三次握手，两次不可以吗，为什么"}},[v._v("#")]),v._v(" 为什么TCP连接需要三次握手，两次不可以吗，为什么")]),v._v(" "),t("p",[v._v("为了实现可靠传输，发送方和接收方始终需要同步( SYNchronize )序号。 需要注意的是， 序号并不是从 0 开始的， 而是由发送方随机选择的初始序列号 ( Initial Sequence Number, ISN )开始 。 由于 TCP 是一个双向通信协议， 通信双方都有能力发送信息， 并接收响应。 因此， 通信双方都需要随机产生一个初始的序列号， 并且把这个起始值告诉对方。")]),v._v(" "),t("p",[t("a",{attrs:{href:"https://blog.csdn.net/lengxiao1993/article/details/82771768",target:"_blank",rel:"noopener noreferrer"}},[v._v("原文链接"),t("OutboundLink")],1)]),v._v(" "),t("hr"),v._v(" "),t("p",[t("a",{attrs:{href:"https://juejin.im/post/586cfcf8da2f600055ce8a8d",target:"_blank",rel:"noopener noreferrer"}},[v._v("面试 -- 网络 TCP/IP"),t("OutboundLink")],1)]),v._v(" "),t("h5",{attrs:{id:"tcp-ip-代表什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-ip-代表什么"}},[v._v("#")]),v._v(" tcp/ip 代表什么")]),v._v(" "),t("ul",[t("li",[v._v("利用 IP 进行通信时所必须用到的协议群的统称")])]),v._v(" "),t("h5",{attrs:{id:"tcp-ip-分层模型与通信示例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-ip-分层模型与通信示例"}},[v._v("#")]),v._v(" TCP/IP 分层模型与通信示例")]),v._v(" "),t("ul",[t("li",[v._v("发包过程\n"),t("ul",[t("li",[v._v("表示层转码，会话层决定何时建立连接，传输层负责建立连接，断开连接和发送数据，保证数据能顺利发送至对端。TCP 协议（传输层）在数据前附加一个首部，这个首部除了包含发送端和接收端地址以外，还包含序号，检验和（判断数据是否被破坏）。IP （网络层）模块将 TCP 传来的首部和数据当数据。加首部，这个首部中包含地址和上一层的协议。链路层除了添加首部，还会添加 FCS 到包尾")])])]),v._v(" "),t("li",[v._v("收包过程\n"),t("ul",[t("li",[v._v("链路层判断 MAC 地址，判断IP 协议。网络层做的事情差不多，在这里，对于有路由器的情况下，借助路由控制表，在找到应该送达的主句或路由器以后再转发数据。传输层检验数据是否被损坏，检验数据是否按照顺序发送，然后再做相同的事情")])])])]),v._v(" "),t("h5",{attrs:{id:"ip-地址"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ip-地址"}},[v._v("#")]),v._v(" IP 地址")]),v._v(" "),t("p",[v._v("每块网卡需配置至少一个 IP 地址")]),v._v(" "),t("p",[v._v("IP 地址由32位正整数组成，为二进制，但是为了人类更好的阅读，将他每8位分为一组，共4组")]),v._v(" "),t("p",[v._v("IP 地址由网络和主机两标识组成")]),v._v(" "),t("ul",[t("li",[v._v("网络标识在数据链路的每个段配置不同的值，必须保证相互连接的端的地址不重复")]),v._v(" "),t("li",[v._v("主机标识不允许在同一网段内重复")])]),v._v(" "),t("p",[v._v("IP 地址分为四个级别，分别为 A, B, C, D")]),v._v(" "),t("ul",[t("li",[v._v("A类地址是首位为 0 开头，前八位是网络标识， 0.0.0.0 ~ 127.0.0.0属于 A 类")]),v._v(" "),t("li",[v._v("B 类地址是前两位由 10 组成，前16位是网络标识，128.0.0.0 ~ 191.255.0.0 属于 B 类")]),v._v(" "),t("li",[v._v("C 类地址前三位是 110， 前24位是网络标识，192.0.0.0 ~ 239.255.255.0 属于 B 类")]),v._v(" "),t("li",[v._v("D 类前四位是 1110，32位全是网络标识，224.0.0.0 ~ 239.255.255.255属于 D 类")])]),v._v(" "),t("p",[v._v("但是以上的分类已经不用，改为使用子网掩码定位网络标识长度。")]),v._v(" "),t("ul",[t("li",[v._v("子网标识同一个网关，255.255.255.0和255.255.255.1是同一个子网")]),v._v(" "),t("li",[v._v("子网掩码也是32位组成")]),v._v(" "),t("li",[v._v("掩码中有几个1就代码几位网络标识，其他为主机标识")]),v._v(" "),t("li",[v._v("假如掩码前24位为1，就代表前24位都为网络标识，用 IP 地址标识就是255.255.255.0，后面的0代表主机标识，理论上有256台主机可连接")])]),v._v(" "),t("h5",{attrs:{id:"路由控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#路由控制"}},[v._v("#")]),v._v(" 路由控制")]),v._v(" "),t("ul",[t("li",[v._v("仅有 IP 地址还不足以将数据包发送到对端，还需指明路由器或主机。保存这种信息的就是路由控制表。")]),v._v(" "),t("li",[v._v("路由控制表中记录着地址与下一步要发送至路由器的地址。在发送 IP 包时，先确定 IP 包首部目标地址，然后在表中找到与该地址具有相同网络地址的记录，根据记录将 IP 包转发给相应的下一个路由器。")])]),v._v(" "),t("h5",{attrs:{id:"ipv6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ipv6"}},[v._v("#")]),v._v(" IPv6")]),v._v(" "),t("p",[v._v("地址长度为128位")]),v._v(" "),t("p",[v._v("解决了很多 IPv4的问题")]),v._v(" "),t("ul",[t("li",[v._v("IP 地址扩大（目前 IPv4地址不足的问题由 NAT解决，NAT 是一种在 IP 数据包通过路由器或防火墙时重写源 IP 地址或目标地址的技术。这种技术被用于多台主机使用单个公有 IP 访问互联网的私有网络中。）")]),v._v(" "),t("li",[v._v("包首部长度固定40字节，路由器不在做分片操作，直接在发送端主机分片")]),v._v(" "),t("li",[v._v("不需 DHCP 服务器也能自动分配 IP地址")]),v._v(" "),t("li",[v._v("使用认证和加密功能")])]),v._v(" "),t("h5",{attrs:{id:"dns"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dns"}},[v._v("#")]),v._v(" DNS")]),v._v(" "),t("ul",[t("li",[v._v("IP 地址不容易记忆，然后出现了域名。DNS 是将域名和 IP 地址相互映射的一个分布式数据库。")]),v._v(" "),t("li",[v._v("DNS 解析\n"),t("ul",[t("li",[v._v("查询 www.baidu.com ，DNS 服务器会先检查自身缓存，有记录则返回结果")]),v._v(" "),t("li",[v._v("记录不存在，DNS 服务器向根域名服务器查询，然后会返回.com 域的权威域名服务器地址")]),v._v(" "),t("li",[v._v("DNS 向 .com 服务器查询，得到 .baidu.com 地址")]),v._v(" "),t("li",[v._v("DNS 向 .baidu.com 服务器查询，得到最终地址，存入缓存并返回结果")])])])]),v._v(" "),t("h5",{attrs:{id:"tcp-与-udp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-与-udp"}},[v._v("#")]),v._v(" TCP 与 UDP")]),v._v(" "),t("p",[v._v("TCP 和 UDP 是传输层的两个具有代表意义的协议.")]),v._v(" "),t("p",[v._v("TCP 是面向有链接的,可靠的协议,TCP 建立连接需要三次握手,断开连接需要四次握手.因为效率比不上 UDP 协议.但是 TCP 协议具有重发包，顺序控制等的机制。")]),v._v(" "),t("p",[v._v("UDP 是面向无连接的协议，不提供复杂的控制机制。做的最重要的事情就是分辨应用层协议。多用于视频音频通讯。")]),v._v(" "),t("p",[v._v("传输层的作用是指出具体该把数据包发给哪个应用，通过端口来分辨应用。")]),v._v(" "),t("blockquote",[t("p",[v._v("TCP有顺序控制的功能，通过一个序列号来确认发送的数据。在发送 SYN 包前，假设主机 A 的初始序列号为1000，以该序号依次往下进行数据编号，然后告诉主机 B 初始序列，同时主机 B 会对 A 的序列号进行确认，假如主机 B 返回一个2000的序列号，则代表字节编号为1000 — 1999，表明主机 B 收到1000字节。")])])])}),[],!1,null,null,null);_.default=r.exports}}]);