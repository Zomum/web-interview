(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{387:function(t,e,v){"use strict";v.r(e);var a=v(42),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[v("a",{attrs:{href:"https://www.cnblogs.com/cxying93/p/6103375.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("资料"),v("OutboundLink")],1)]),t._v(" "),v("p",[t._v("定义：当一个函数的返回值是另外一个函数，而返回的那个函数如果调用了其父函数内部的变量，且返回的这个函数在外部被执行，就产生了闭包。")]),t._v(" "),v("p",[t._v("是一个环境，能够读取其他函数内部的变量")]),t._v(" "),v("p",[t._v("本质：闭包是将函数内部和外部函数连接起来的桥梁。")]),t._v(" "),v("p",[t._v("用处：1.读取函数内部的变量")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",[v("code",[t._v("\t2.这些变量的值始终保持在内存中，不会再外层函数调用后被自动清掉。\n")])])]),v("p",[t._v("缺点：常驻内存，会增大内存的使用量，使用不当会造成内存泄漏。")]),t._v(" "),v("p",[t._v("优点：1.变量长期驻扎在内存中")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",[v("code",[t._v("\t  2.避免全局变量的污染\n\n\t 3.私有成员的存在。\n")])])]),v("p",[t._v("场景：解决索引值问题")]),t._v(" "),v("p",[t._v("实现(特性): 1.函数套函数")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",[v("code",[t._v("\t\t\t 2.内部函数可以直接使用外部函数的局部变量或参数\n\n\t\t\t 3.变量或参数不会被垃圾回收机制回收\n")])])]),v("p",[t._v("答：在js中变量作用域：全局变量和局部变量，javascript语言的特别之处就在于：函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量。声明用var，不然是全局变量，从外部读取函数内部的局部变量，就有了闭包。")]),t._v(" "),v("p",[t._v("闭包可以简单理解成“定义在一个函数内部的函数“。所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁。")]),t._v(" "),v("p",[t._v("用途：1）读取函数内部的变量，2）就是让这些变量的值始终保持在内存中，不会在f1调用后被自动清除。")]),t._v(" "),v("p",[t._v("缺点：（1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。")]),t._v(" "),v("p",[t._v("（2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值")])])}),[],!1,null,null,null);e.default=n.exports}}]);