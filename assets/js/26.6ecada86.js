(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{380:function(o,t,_){"use strict";_.r(t);var p=_(42),v=Object(p.a)({},(function(){var o=this,t=o.$createElement,_=o._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[_("p",[o._v("1、所有的引用类型（数组、函数、对象）可以自由扩展属性（除null以外）。")]),o._v(" "),_("p",[o._v("2、所有的引用类型都有一个’_ _ proto_ _'属性(也叫隐式原型，它是一个普通的对象)。")]),o._v(" "),_("p",[o._v("3、所有的函数都有一个’prototype’属性(这也叫显式原型，它也是一个普通的对象)。")]),o._v(" "),_("p",[o._v("4、所有引用类型，它的’_ _ proto_ _'属性指向它的构造函数的’prototype’属性。")]),o._v(" "),_("p",[o._v("5、当试图得到一个对象的属性时，如果这个对象本身不存在这个属性，那么就会去它的’_ _ proto_ _'属性(也就是它的构造函数的’prototype’属性)中去寻找。")]),o._v(" "),_("ul",[_("li",[_("code",[o._v("Object")]),o._v(" 是所有对象的爸爸，所有对象都可以通过 "),_("code",[o._v("__proto__")]),o._v(" 找到它")]),o._v(" "),_("li",[_("code",[o._v("Function")]),o._v(" 是所有函数的爸爸，所有函数都可以通过 "),_("code",[o._v("__proto__")]),o._v(" 找到它")]),o._v(" "),_("li",[_("code",[o._v("Function.prototype")]),o._v(" 和 "),_("code",[o._v("Object.prototype")]),o._v(" 是两个特殊的对象，他们由引擎来创建")]),o._v(" "),_("li",[o._v("除了以上两个特殊对象，其他对象都是通过构造器 "),_("code",[o._v("new")]),o._v(" 出来的")]),o._v(" "),_("li",[o._v("函数的 "),_("code",[o._v("prototype")]),o._v(" 是一个对象，也就是原型")]),o._v(" "),_("li",[o._v("对象的 "),_("code",[o._v("__proto__")]),o._v(" 指向原型， "),_("code",[o._v("__proto__")]),o._v(" 将对象和原型连接起来组成了原型链")])]),o._v(" "),_("p",[o._v("1、原型链是单链，只往一个方向流向，没有回路")]),o._v(" "),_("p",[o._v("2、只有Function的__proto__指向自己的prototype，这也向我们解释了为什么Function.prototype类型是function")]),o._v(" "),_("p",[o._v("3、我们通过__proto__只能获取到原型对象中的方法和属性，所以persion1通过原型链是获取不到Persion的myName属性，但是我们可以通过原型对象的constructor来获取或者修改Persion的属性（这点太给力了）")]),o._v(" "),_("p",[o._v("请注意，有时候这个方法也不好使，因为原型对象的constructor是可以改变的，不一定指向原型对象所在的函数对象")]),o._v(" "),_("p",[o._v("4、普通对象的_proto__一定指向创造它的函数对象的prototype")]),o._v(" "),_("p",[o._v("5、原型对象的__proto__一定指向Object.prototype！")]),o._v(" "),_("p",[o._v("6、通过图我们可以简单理解，拥有原型对象属性的对象是函数对象，否则为普通对象")]),o._v(" "),_("p",[o._v("7、原型链是有开始和尽头的，开始于null，结束于普通对象")]),o._v(" "),_("p",[o._v("8、所有的函数对象都是Function以new的方式创造出来了，包括Function自己且每个函数对象的__proto__都指向了Function.prototype")]),o._v(" "),_("p",[o._v("9、Object是所有对象的父类，我们也可以称之为基类，不过不要纠结于叫什么，因为我们通过图可以看到每一个对象（不管是原型对象还是普通对象还是函数对象）的通过原型链都可以引向Object.prototype")]),o._v(" "),_("p",[o._v("Function.prototype."),_("strong",[o._v("proto")]),o._v(" === Object.prototype;")]),o._v(" "),_("p",[_("img",{attrs:{src:"img/WechatIMG7.jpeg",alt:"WechatIMG7"}})]),o._v(" "),_("p",[_("img",{attrs:{src:"img/1573095096683.jpg",alt:"1573095096683"}})]),o._v(" "),_("p",[o._v("实例对象(f1 = new Foo()) 的 隐式原型("),_("strong",[o._v("proto")]),o._v(") 指向它的 构造函数(Foo()) 的 prototype(显式原型对象) 属性")]),o._v(" "),_("p",[o._v("f1."),_("strong",[o._v("proto")]),o._v(" = Foo.prototype")]),o._v(" "),_("p",[o._v("构造函数(Foo()) 的 prototype 属性叫做原型对象(Foo.prototype)，原型对象(Foo.prototype)的constructor属性就是构造函数(Foo())本身")]),o._v(" "),_("p",[o._v("Foo. prototype = Foo. prototype. constructor")]),o._v(" "),_("p",[o._v("实例对象(o1 = new Object()) 的 "),_("strong",[o._v("proto")]),o._v("(隐式原型) 指向 Object(构造函数) 的 prototype(显式原型对象)")]),o._v(" "),_("p",[o._v("o1."),_("strong",[o._v("proto")]),o._v(" = Object. prototype")]),o._v(" "),_("p",[_("img",{attrs:{src:"https://img-blog.csdn.net/20180909114030465?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTk2Mjcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70",alt:"这里写图片描述"}})]),o._v(" "),_("blockquote",[_("p",[o._v("注：我们可以通过hasOwnProperty方法来判断一个属性是否从原型链中继承而来。")])]),o._v(" "),_("p",[_("img",{attrs:{src:"img/1573722087778.jpg",alt:"1573722087778"}})])])}),[],!1,null,null,null);t.default=v.exports}}]);